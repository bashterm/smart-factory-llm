from copy        import copy
from collections import Counter
from math        import ceil

class Coordinator:

  def __init__(self, procedures):

    # Get a map from each process id to the number of times that it has to be run
    self.unassigned = Counter()
    for procedure in procedures.procedures:
      self.unassigned += (
        self.get_required_process_runs(procedure, procedures.required_runs[procedure.id]))
    
  # Find the multiset of processes that need to be run to run the procedure num_runs times. Recall 
  # that no token in a procedure is generated by two different processes. 
  def get_required_process_runs(self, procedure, num_runs):

    required_process_runs = Counter()  # Process Id -> # of runs required
    required_tokens       = Counter()  # Token Id   -> # of tokens required

    # Initialize required tokens with num_execution copies of the token consumed by the
    # procedure's output function
    output_process_id = procedure.output_process
    output_process    = procedure.processes[output_process_id]
    required_tokens  += output_process.inputs

    # print(f"procedure:{procedure.id}")
    # print(f"required_tokens:{required_tokens}")

    # While there is an required token not generated:
    while any(required_tokens.values()):

      # Get the token to produce
      token = next(tk for tk, num_required in required_tokens.items() if num_required)

      # Find the process that produces that token
      p_id, process  = (
        next((p_id, p) for p_id, p in procedure.processes.items() if token in p.outputs))

      # Work out how many times the process needs to be run
      run_num = ceil(required_tokens[token] / process.outputs[token])

      # Add the required tokens to execute the process run_num times
      for _ in range(run_num): required_tokens += process.inputs

      required_process_runs[p_id] += run_num
      del required_tokens[token]

    return required_process_runs

  def print_unassigned_processes(self):
    input(f"unassigned_processes:{self.unassigned}")